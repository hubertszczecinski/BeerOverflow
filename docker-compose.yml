services:
  # The Flask Backend Service
  backend:
    build:
      context: ./backend  # Path to the backend's Dockerfile and code
    container_name: flask-backend
    environment:
      - FACE_API_URL=http://face-recognition:8000
      - DB_PATH=/app/data/bank.db
      - SECRET_KEY=${SECRET_KEY:-dev-secret-key-change-in-production}
      - DEPLOYMENT_MODE=${DEPLOYMENT_MODE:-development}
      - DOMAIN_NAME=${DOMAIN_NAME:-localhost}
      - DOC_ANALYSIS_URL=http://doc-analysis:9000
    ports:
      - "5000:5000"  # Map host port 5000 to container port 5000
    volumes:
      - backend-data:/app/data  # Persist SQLite database file
    #depends_on:
    #  - face-recognition
    #  - doc-analysis

  face-recognition:
    build:
      context: ./face_recognition
    container_name: face-recognition-service
    ports:
      - "8000:8000"
    # TODO: hide all these service ports for production deployment
    # all traffic should go through frontend->backend only
    volumes:
      - deepface-weights:/root/.deepface/weights
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [ gpu ]
    #healthcheck:
    #  test: [ "CMD", "curl", "-f", "http://localhost:5000/health" ]
    #  interval: 30s
    #  timeout: 10s
    #  retries: 3

  doc-analysis:
    build:
      context: ./doc_analysis
    container_name: doc-analysis-service
    environment:
      - GROQ_API_KEY=${GROQ_API_KEY:-}
    ports:
      - "9000:9000"
    volumes:
      - ./doc_analysis/data:/app/data

  voice-assist:
    build:
      context: ./whisper_endpoint
    container_name: voice-assist-service
    ports:
        - "7000:8000"
  # The Vue.js Frontend Service
  frontend:
    build:
      context: ./frontend # Path to the frontend's Dockerfile and code
    container_name: vue-frontend
    environment:
      - DEPLOYMENT_MODE=${DEPLOYMENT_MODE:-development}
      - DOMAIN_NAME=${DOMAIN_NAME:-localhost}
      - LETSENCRYPT_EMAIL=${LETSENCRYPT_EMAIL:-}
    ports:
      - "${HTTP_PORT:-8080}:80"    # HTTP port (8080 for dev, 80 for prod)
      - "${HTTPS_PORT:-8443}:443"  # HTTPS port (8443 for dev, 443 for prod)
    volumes:
      # For Let's Encrypt certificates in production
      - letsencrypt-certs:/etc/letsencrypt
      - certbot-www:/var/www/certbot
    depends_on:
      - backend    # Ensures the backend service starts before the frontend

  # Certbot for Let's Encrypt SSL certificates (production only)
  # To obtain certificates, run: docker-compose run --rm certbot certonly --webroot --webroot-path=/var/www/certbot -d commerzbank.valchak.com
  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - letsencrypt-certs:/etc/letsencrypt
      - certbot-www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    profiles:
      - production  # Only start in production

networks:
  default:
    driver: bridge
volumes:
  deepface-weights:
  backend-data:
  letsencrypt-certs:
  certbot-www:
